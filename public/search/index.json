[{"content":"头歌-DeepDream Part 1 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 from keras import backend as K import matplotlib matplotlib.use(\u0026#39;Agg\u0026#39;) from matplotlib import pyplot as plt import numpy as np def feature_map_vis(model, image): \u0026#39;\u0026#39;\u0026#39; 将model的第6层所生成最后4个特征图可视化，并保存到./step1/result/feature_map.png中 :param model: VGG16模型 :param image: 待输入的图像，类型为ndarray，shape为(224, 224, 3) :return: 无 \u0026#39;\u0026#39;\u0026#39; #********* Begin *********# getf = K.function([model.layers[0].input], [model.layers[6].output]) fimgs = getf([np.expand_dims(image, axis=0)])[0] for i in range(4): show_img = fimgs[:, :, :, i] show_img.shape = [fimgs.shape[1], fimgs.shape[2]] plt.subplot(1, 4, i+1) plt.imshow(show_img, cmap=\u0026#39;gray\u0026#39;) plt.axis(\u0026#39;off\u0026#39;) plt.savefig(\u0026#39;./step1/result/feature_map.png\u0026#39;) #********* End *********# Part 2 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 from keras import backend as K import numpy as np def update_img(epochs, input_layer, feature_map, learning_rate): \u0026#39;\u0026#39;\u0026#39; 随机生成1张宽224，高224的RGB图像，并更行图像 :param epochs: 梯度上升的迭代次数 :param input_layer: CNN模型的输入层 :param feature_map: CNN模型的指定的特征图 :param learning_rate: 梯度上升的学习率 :return: 更新后的图像和，其中图像的维度为(图像的高，图像的宽，通道数) \u0026#39;\u0026#39;\u0026#39; #********* Begin *********# # 创建一个随机初始化的图像 img = np.random.randint(low=0, high=255, size=(1, 224, 224, 3)) img = img / 255.0 # 归一化处理 # 定义损失函数为特征图的均值 loss = K.mean(feature_map) # 计算损失函数对图像的梯度并进行归一化 grads = K.gradients(loss, input_layer)[0] grads = grads / (K.sqrt(K.mean(K.square(grads))) + K.epsilon()) # 定义前向传播操作 iterate = K.function([input_layer], [loss, grads]) # 迭代epochs次梯度上升 for _ in range(epochs): # 得到当前的损失值与梯度 loss_value, grads_value = iterate([img]) # 根据梯度上升的公式更新图像 img += grads_value * learning_rate # 如果更新不动了就提前返回 if loss_value \u0026lt;= K.epsilon(): break # 返回更新后的图像 return img[0] #********* End *********# Part 3 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 from keras import backend as K import numpy as np def deep_dream(img, model, epochs, learning_rate, max_threshold): \u0026#39;\u0026#39;\u0026#39; 将VGG16的block4_conv1与block5_conv2用来做deep dream，其中block4_conv1的权重为0.05，block5_conv2的权重为0.2，并将图像返回 :param img: 预处理后的图像，类型为ndarray，shape为(样本个数，图像的宽，图像的高，通道数) :param model: VGG16 :param epochs: 梯度上升的迭代次数 :param learning_rate: 梯度上升的学习率 :param max_threshold: 损失值的最大阈值 :return: deep dream后的图像，其中图像的维度为(图像的高，图像的宽，通道数) \u0026#39;\u0026#39;\u0026#39; #********* Begin *********# layer_contributions = { \u0026#39;block4_conv1\u0026#39;: 0.05, \u0026#39;block5_conv2\u0026#39;: 0.2 } # 定义一个包含损失的张量，即上面列出的激活的L2范数的加权和。 layer_dict = dict([(layer.name, layer) for layer in model.layers]) # 定义损失 loss = K.variable(0.) for layer_name in layer_contributions: # 将丢失的图层特征的L2范数添加到损失中。 coeff = layer_contributions[layer_name] activation = layer_dict[layer_name].output # 通过仅涉及损失中的非边界像素来避免边界伪影。 scaling = K.prod(K.cast(K.shape(activation), \u0026#39;float32\u0026#39;)) loss += coeff * K.sum(K.square(activation[:, :, :, :])) / scaling dream = model.input # 计算损失的梯度的变化 grads = K.gradients(loss, dream)[0] # 标准化梯度 grads /= K.maximum(K.mean(K.abs(grads)), 1e-7) # 设置函数以检索给定输入图像的损失和梯度值。 outputs = [loss, grads] fetch_loss_and_grads = K.function([dream], outputs) def eval_loss_and_grads(x): outs = fetch_loss_and_grads([x]) loss_value = outs[0] grad_values = outs[1] return loss_value, grad_values for i in range(epochs): loss_value, grad_values = eval_loss_and_grads(img) if max_threshold is not None and loss_value \u0026gt; max_threshold: break img = img + learning_rate * grad_values return img #********* End *********# ","date":"2023-12-19T03:11:31Z","permalink":"https://days-gone.github.io/p/educoder13/","title":"Educoder13"},{"content":"Hello, Welcome to my blog!\n","date":"2023-12-06T09:01:58Z","permalink":"https://days-gone.github.io/p/hello/","title":"Hello!"},{"content":"Operate System Windows 大家都比较熟悉，暂且先不做介绍\nLinux Ubuntu 给出一个比较好的B站视频链接：\nWindows 和 Ubuntu 双系统的安装和卸载_哔哩哔哩_bilibili\n浏览器 浏览器作为访问web网页的客户端，使用体验的影响比较大，这里介绍一些浏览器（不包含mac端）。在安装时建议在你的C盘外的硬盘上开辟新的文件夹安装。\nEdge Download Microsoft Edge\nFirefox火狐 Firefox 火狐浏览器 - 全新、安全、快速 | 官方最新下载\nChrome Google Chrome 网络浏览器\n搜索引擎 浏览器的体验其实也有很大部分决定于搜索引擎，如果你用过百度那么你一定知道，当你搜索某项事物时，排名最靠上的那几个就往往不是你想要的（多半是广告/一些“下崽”软件）。\nBing 如果你使用的是Edge那么默认的搜索引擎就是bing，他是由微软提供的一款搜索引擎。\nBing\nGoogle 全球最大的搜索引擎，但是搜索结果中含有英文结果比较多，比较锻炼大家的英文水平。缺点是需要使用科学上网。\nGoogle\nIDE ide是我们平常工作的地方，有一个你满意的ide环境会让你工作的更加舒心。在这里我们分语言进行推荐。\nC++ Dev-C++ 更适合新手入门快速部署本地C++编译环境，省去了花费在环境配置上的经历，更专注于快速入手学习C++的语法。\nMicrosoft Visual Studio 由微软公司开发，为C/C++提供专业的工作环境，对于初学者而言安装比较简单，无需自己配置太多东西。\nVisual Studio Code 也是由微软公司开发，但相对于MVS更加轻量级，拥有比较多的拓展包可供下载。是IDE中的万金油！使用我们之前推荐的搜索引擎进行下载即可。因为自己用的比较多的是VSC，所以就先介绍VScode吧。\nTRY VScode入门 简单了解 LSP即Language Server Protocol，LSP是少数基于JSON的语言服务器数据交换协定，由GitHub代管，并采用CC及MIT授权。该协定主要用来促进编辑器及语言服务器之间的互动，允许开 发人员在各种编辑器或整合开发环境中存取智慧型的程序语言工具，像是以符号搜寻、语法分析、自动完成代码、移至定义、描绘轮廓或重构等。LSP一个非常显著的功能就是智能感知（包括智能提示、错误检测、文件/函数跳转，IntelliSense）。\nC语言常见的LSP插件有：clangd、ccls、**MS的C++**拓展。对于单个文件的C++程序你可以采用MS的C++拓展，或者Clangd，但对于多文件的C++工程来说我们更推荐使用Clangd + Cmake + CmakeTools的编辑器设置，比较好用。\n配置自己的VScode-C++环境。 首先安装好VScode，注意此处假设我们的电脑用户名不出现中文，因为似乎在最新的MingW中如果要使用LLDB进行调试那么你的C盘下的用户是不可以为中文名的，否则会调试的时候出现找不到LLDB插件的错误。\n假设我们已经安装好了VScode，并且将MingW下的bin目录和CMake添加到了环境变量中，那么接下来，打开VScode：\n1、点击拓展栏，搜索“Clangd”，并安装。\n2、搜索“CMake Tools”下载并安装。\n3、点击左下角的设置，并在搜索栏中输入“clangd path\u0026quot;，在对应的栏中输入clangd的具体位置（如果你已经添加了环境变量可以直接输入clangd，否则就写出完整的路径。）\n4、创建一个新的项目文件夹假设此处就叫做Project，在Project/ 下创建一个叫做CMakeLists.txt的文件，注意大小写。之后我们就可以使用CMakeLists.txt来管理我们这个项目的构建过程了。\n5、创建几个新的文件夹满足：Project/src, Project/build, Project/include这样的结构，在我们的src文件夹下面创建一个新的cpp文件，假如叫做main.cpp。那么在main.cpp中输入:\n1 2 3 4 5 6 #include \u0026lt;iostream\u0026gt; int main(){ std::cout \u0026lt;\u0026lt; \u0026#34;hello,c++\u0026#34;; return 0; } 接下来修改CMakeLists.txt:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 cmake_minimum_required(VERSION 3.12) project(BoostExample) set(CMAKE_CXX_STANDARD 14) # Find Boost components # find_package(Boost REQUIRED COMPONENTS filesystem) # Add the include directory # 我们自己写的头文件可以放在这个include目录下面 include_directories(include) # Add the executable target # 生成可执行文件即能够运行的程序 add_executable(result src/main.cpp) 此处只是做了一个非常简单的介绍，具体的文件可以阅读Cmake的文档。\n6、重新打开VScode，注意点击左上角的“文件-\u0026gt;打开文件夹-\u0026gt;选中Project（这个文件夹的一级子目录下应该有个CMakeLists.txt）。打开之后，clangd和cmaketools会自动扫描可使用的套间（clang++、g++）等，选择你的套件。之后在左下角往右浏览找到build或者一个三角形（像播放按钮的形状）并点击，；build只生成可执行文件，而运行则会生成并执行该文件。\n记笔记 这里我们说的是在学习过程中记录blog式的笔记软件推荐：\nMarkdown Markdown是一种轻量级标记语言，排版语法简洁，让人们更多地关注内容本身而非排版。它使用易读易写的纯文本格式编写文档，可与HTML混编，可导出 HTML、PDF 以及本身的 .md 格式的文件。因简洁、高效、易读、易写，Markdown被大量使用，如Github、Wikipedia、简书等。 \u0026ndash; markdown official introduction\nMarkdown 基本语法 | Markdown 官方教程\nTypora 给出一些文章链接来介绍吧：\n2020Typora小白完全使用教程\ntypora是什么软件_一款好用的轻量级Markdown编辑器 - 极客库\nZettlr LateX latex适合用于写一些论文/报告之类的任务，如果你也对word的使用不够熟悉并烦恼于它的布局配置问题的话，不如学习latex来完成你的任务，初学需要花费时间了解latex的使用方法，但一旦学会就会省去很多时间并轻松完成精美的布局设置。\n因为自己只使用过线上的，所以推荐一下这个网站。\nOverleaf, Online LaTeX Editor\nTutorial:\nLearn LaTeX in 30 minutes\nThank U For Reading ","date":"2023-12-06T09:01:58Z","permalink":"https://days-gone.github.io/p/tools_recomended/","title":"Tools_recomended"}]